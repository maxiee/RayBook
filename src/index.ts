import { app, BrowserWindow, ipcMain, dialog } from 'electron';
import EPub from 'epub2';
import path from 'path';
import fs from 'fs';
import mongoose from 'mongoose';
import Book from './models/Book';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// 连接到 MongoDB, ENV RAYBOOK_MONGO_URI
mongoose.connect(process.env.RAYBOOK_MONGO_URI);

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
ipcMain.handle('upload-epub', async () => {
  try {
    const result = await dialog.showOpenDialog({
      properties: ['openFile'],
      filters: [{ name: 'EPUB Files', extensions: ['epub'] }],
    });

    if (result.canceled || result.filePaths.length === 0) {
      return { success: false };
    }

    const filePath = result.filePaths[0];
    const epub: EPub = await EPub.createAsync(filePath);
    console.log(epub.metadata);

    let coverBase64 = null;
    let coverMimeType = null;

    // 尝试获取封面信息
    if (epub.metadata.cover) {
      try {
        const coverData: { data: Buffer, mimeType: string; } = await new Promise((resolve, reject) => {
          epub.getImage(epub.metadata.cover, (err: Error, data: Buffer, mimeType: string) => {
            if (err) reject(err);
            else resolve({ data, mimeType });
          });
        });

        coverBase64 = `data:${coverData.mimeType};base64,${coverData.data.toString('base64')}`;
        coverMimeType = coverData.mimeType;
      } catch (error) {
        console.error('Error extracting cover:', error);
      }
    }

    const metadata = {
      title: epub.metadata.title,
      author: epub.metadata.creator,
      publisher: epub.metadata.publisher,
      isbn: epub.metadata.ISBN,
      language: epub.metadata.language,
      publicationYear: new Date(epub.metadata.date).getFullYear(),
      coverBase64: coverBase64,
      coverMimeType: coverMimeType,
    };

    return { success: true, metadata };
  } catch (error) {
    console.error('Error reading EPUB:', error);
    return { success: false };
  }
});

// 处理图书添加
ipcMain.handle('add-book', async (event, bookData) => {
  try {
    // 处理封面图片
    let coverImage;
    if (bookData.coverBase64) {
      const base64Data = bookData.coverBase64.replace(/^data:image\/\w+;base64,/, "");
      const buffer = Buffer.from(base64Data, 'base64');
      console.log('coverMimeType' + bookData.contentType);
      coverImage = {
        data: buffer,
        contentType: bookData.contentType
      };
    }

    // 保存 EPUB 文件
    // const epubFileName = `${Date.now()}_${path.basename(bookData.epubPath)}`;
    // const epubDestPath = path.join(app.getPath('userData'), 'books', epubFileName);
    // await fs.promises.copyFile(bookData.epubPath, epubDestPath);

    // 创建新的 Book 文档
    const newBook = new Book({
      ...bookData,
      coverImage,
      // epubPath: epubDestPath
    });

    // 保存到数据库
    await newBook.save();

    return { success: true, message: '图书添加成功' };
  } catch (error) {
    console.error('添加图书时出错:', error);
    return { success: false, message: '添加图书失败' };
  }
});

// 添加新的 IPC 接口用于分页加载最新添加的书籍
ipcMain.handle('get-latest-books', async (event, page = 1, pageSize = 10) => {
  try {
    const skip = (page - 1) * pageSize;
    const books = await Book.find({})
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(pageSize)
      .lean() // 使用 lean() 来获取普通 JavaScript 对象
      .select('title author coverImage');
    
    // 转换 coverImage.data 为 Base64 字符串
    const processedBooks = books.map(book => ({
      ...book,
      coverImage: book.coverImage ? {
        contentType: book.coverImage.contentType,
        data: book.coverImage.data.toString('base64')
      } : null
    }));

    const total = await Book.countDocuments();

    return {
      success: true,
      data: processedBooks,
      total,
      currentPage: page,
      pageSize,
    };
  } catch (error) {
    console.error('Error fetching latest books:', error);
    return { success: false, message: '获取最新书籍失败' };
  }
});