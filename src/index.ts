import { app, BrowserWindow, ipcMain, dialog, session } from "electron";
import path from "path";
import fs from "fs";
import mongoose from "mongoose";
import { IBook } from "./models/Book";
import { minioEndpoint } from "./data/minio/MinioClient";
import { CoverIamgeRepostory } from "./repository/CoverImageRepostory";
import { localBookCache } from "./services/LocalBookCacheService";
import { epubMetadaService } from "./services/EpubMetadataService";
import { registerIpcHandlers } from "./core/ipc/IpcWrapper";
import { bookFileService } from "./services/bookfile/BookFileServiceImpl";
import { bookService } from "./services/book/BookServiceImpl";
import { bookCoverService } from "./services/bookcover/BookCoverServiceImpl";
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
      webSecurity: false, // 警告：这会禁用所有的 web 安全性检查
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // 设置 CSP
  session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
    let csp;
    if (process.env.NODE_ENV === "development") {
      // 开发环境的 CSP
      csp = [
        "default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: file:;",
        "script-src 'self' 'unsafe-inline' 'unsafe-eval';",
        `img-src 'self' data: ${minioEndpoint} blob: file:;`,
        "style-src 'self' 'unsafe-inline' blob:;",
        "font-src 'self' data: file:;",
        `connect-src 'self' ws: ${minioEndpoint} http://localhost:* http://0.0.0.0:* file: blob:;`,
      ].join(" ");
    } else {
      // 生产环境的 CSP
      csp = [
        "default-src 'self' 'unsafe-inline' data: blob: file:;",
        `img-src 'self' data: ${minioEndpoint} file:;`,
        "style-src 'self' 'unsafe-inline' blob:;",
        "font-src 'self' data: file:;",
        `connect-src 'self' ${minioEndpoint} file: blob:;`,
      ].join(" ");
    }

    callback({
      responseHeaders: {
        ...details.responseHeaders,
        "Content-Security-Policy": csp,
      },
    });
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  mainWindow.webContents.on("will-navigate", (event, url) => {
    event.preventDefault();
    mainWindow.loadURL(url);
  });

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// 连接到 MongoDB, ENV RAYBOOK_MONGO_URI
mongoose.connect(process.env.RAYBOOK_MONGO_URI);

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// 注册 IPC 处理程序
registerIpcHandlers(bookService);
registerIpcHandlers(bookFileService);
registerIpcHandlers(bookCoverService);

ipcMain.handle("get-local-book-content", async (event, bookId: Id) => {
  try {
    const bookFiles = await bookfileRepository.findBookFilesByBookId(bookId);
    if (bookFiles.length === 0) {
      return { success: false, message: "No book file found" };
    }

    const filePath = await localBookCache.getBookFile(
      bookId,
      bookFiles[0].path
    );
    const content = fs.readFileSync(filePath);
    console.log("get-local-book-content ", content.buffer.byteLength);

    return { success: true, content: content.buffer };
  } catch (error) {
    console.error("Error getting local book path:", error);
    return { success: false, message: "Failed to get local book content" };
  }
});

// 更新书籍信息
ipcMain.handle("update-book", async (event, book: IBook | null) => {
  try {
    return await bookRepository.updateBook(book);
  } catch (error) {
    console.error("更新图书时出错:", error);
    return null;
  }
});

// 处理图书添加
ipcMain.handle(
  "add-book",
  async (event, book: IBook): Promise<IBook | null> => {
    try {
      const newBook = await bookRepository.createNewBook(book);
      return newBook;
    } catch (error) {
      console.error("添加图书时出错:", error);
      return null;
    }
  }
);

ipcMain.handle("add-new-book", async (event) => {
  const result = await dialog.showOpenDialog({
    properties: ["openFile"],
    filters: [{ name: "Ebooks", extensions: ["epub"] }],
  });

  if (result.canceled || result.filePaths.length === 0) {
    return { success: false, message: "No file selected" };
  }

  const filePath = result.filePaths[0];
  const fileName = path.basename(filePath);
  const objectName = `books/${Date.now()}_${fileName}`;
  console.log("add-new-book filePath:", filePath);
  console.log("add-new-book objectName:", objectName);
  console.log("add-new-book fileName:", fileName);

  const metadata = await epubMetadaService.extractMetadata(filePath);
  console.log("add-new-book metadata:", metadata);

  const newBook = await bookRepository.createNewBook({
    title: metadata.title,
    author: metadata.creator,
    publisher: metadata.publisher,
    isbn: metadata.ISBN,
    publicationYear: new Date(metadata.date).getFullYear(),
  });
  console.log("add-new-book newBook:", newBook);

  const newUploadBookFile = await bookfileRepository.uploadBookFile(
    newBook._id,
    filePath,
    fileName,
    objectName
  );
  console.log("add-new-book newUploadBookFile:", newUploadBookFile);

  const coverIamgeUrl = await coverImageRepository.uploadBookCoverImage(
    newBook._id,
    filePath
  );
  console.log("add-new-book coverIamgeUrl:", coverIamgeUrl);

  return {
    success: true,
    message: "Book added successfully",
    bookId: newBook._id,
  };
});

// // 删除书籍文件
// ipcMain.handle('delete-book-file', async (event, fileId) => {
//   try {
//     const bookFile = await BookFile.findById(fileId);
//     if (!bookFile) {
//       return { success: false, message: '文件不存在' };
//     }

//     // 从 MinIO 删除文件
//     await s3Client.deleteObject({
//       Bucket: 'raybook',
//       Key: bookFile.path
//     }).promise();

//     // 从数据库中删除文件记录
//     await BookFile.findByIdAndDelete(fileId);

//     // 更新相关的 Book 文档
//     await Book.findByIdAndUpdate(bookFile.book, { $pull: { files: fileId } });

//     return { success: true, message: '文件删除成功' };
//   } catch (error) {
//     console.error('删除文件时出错:', error);
//     return { success: false, message: '删除文件失败' };
//   }
// });
