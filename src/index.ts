import {
  app,
  BrowserWindow,
  BrowserView,
  ipcMain,
  session,
  WebContents,
} from "electron";
import mongoose from "mongoose";
import { minioEndpoint } from "./data/minio/MinioClient";
import { epubService } from "./services/epub/EpubServiceImpl";
import { registerIpcHandlers } from "./core/ipc/IpcWrapper";
import { bookFileService } from "./services/bookfile/BookFileServiceImpl";
import { bookService } from "./services/book/BookServiceImpl";
import { bookCoverService } from "./services/bookcover/BookCoverServiceImpl";
import { fileService } from "./services/file/FileServiceImpl";
import isDev from "electron-is-dev";
import { logService } from "./services/log/LogServiceImpl";
import Store from "electron-store";
import { debounce } from "ts-debounce";
import { URL } from "url";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const DEBUG_WEIXIN_READ = false;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

Store.initRenderer();

let weixinReadBrowserView: BrowserView | null = null;
let mainWindow: BrowserWindow | null = null;

const createWindow = (): void => {
  logService.info("Application started");
  logService.info("Maxiee 是否是测试环境", isDev);
  logService.info(MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY);
  logService.info(MAIN_WINDOW_WEBPACK_ENTRY);
  // Create the browser window.
  mainWindow = new BrowserWindow({
    title: "RayBook",
    height: 600,
    width: 800,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
      webSecurity: false, // 警告：这会禁用所有的 web 安全性检查
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // 设置 CSP
  session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
    let csp;
    if (process.env.NODE_ENV === "development") {
      // 开发环境的 CSP
      csp = [
        "default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: file:;",
        "script-src 'self' 'unsafe-inline' 'unsafe-eval';",
        `img-src 'self' data: ${minioEndpoint} cdn.weread.qq.com blob: file:;`,
        "style-src 'self' 'unsafe-inline' blob:;",
        "font-src 'self' data: file:;",
        `connect-src 'self' ws: ${minioEndpoint} http://localhost:* http://0.0.0.0:* file: blob:;`,
      ].join(" ");
    } else {
      // 生产环境的 CSP
      csp = [
        "default-src 'self' 'unsafe-inline' data: blob: file:;",
        `img-src 'self' data: ${minioEndpoint} file:;`,
        "style-src 'self' 'unsafe-inline' blob:;",
        "font-src 'self' data: file:;",
        `connect-src 'self' ${minioEndpoint} file: blob:;`,
      ].join(" ");
    }

    callback({
      responseHeaders: {
        ...details.responseHeaders,
        "Content-Security-Policy": csp,
      },
    });
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  mainWindow.webContents.on("will-navigate", (event, url) => {
    event.preventDefault();
    mainWindow.loadURL(url);
  });

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  logService.info("Application exited");
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  logService.info("Application activated");
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// 连接到 MongoDB, ENV RAYBOOK_MONGO_URI
mongoose.connect(process.env.RAYBOOK_MONGO_URI);

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// 注册 IPC 处理程序
registerIpcHandlers(bookService);
registerIpcHandlers(bookFileService);
registerIpcHandlers(bookCoverService);
registerIpcHandlers(fileService);
registerIpcHandlers(epubService);
registerIpcHandlers(logService);

ipcMain.on("config-updated", () => {
  app.relaunch();
  app.exit(0);
});

// 定义请求数据的类型
type RequestData = { [key: string]: any };

// 定义处理函数类型
type WeReadHandler = (bookKey: string) => void;

// 定义每本书的请求数据映射
type BookRequestMap = Map<string, RequestData>;

// 定义全局数据存储
const globalBookData: Map<string, BookRequestMap> = new Map();

// 当前正在阅读的书籍的 key
let currentBookKey: string | null = null;

// 创建一个处理函数
const handleWeReadUrl: WeReadHandler = (bookKey: string) => {
  logService.info(`Detected WeRead book with Key: ${bookKey}`);
  currentBookKey = bookKey;

  // 如果这是一本新书，为它创建一个新的 Map
  if (!globalBookData.has(bookKey)) {
    globalBookData.set(bookKey, new Map());
  }

  // 向渲染进程发送消息
  mainWindow.webContents.send("weixin-read-book-opened", bookKey);
};

ipcMain.handle("get-book-data", (event, bookKey: string) => {
  const bookData = globalBookData.get(bookKey);
  logService.debug("get-book-data 获取书籍数据:", bookData);
  return bookData ? Object.fromEntries(bookData) : null;
});

ipcMain.on("weixin-read:init", async (event, contentBounds) => {
  const win = BrowserWindow.fromWebContents(event.sender);
  if (!win) return;

  if (!weixinReadBrowserView) {
    // 创建一个新的 session
    const weixinReadSession = session.fromPartition("persist:weread");

    weixinReadSession.webRequest.onHeadersReceived((details, callback) => {
      const sites =
        "https://cdn.weread.qq.com https://midas.gtimg.cn https://*.myqcloud.com https://*.qq.com https://*.qqmail.com https://*.tencent-cloud.com data:";
      callback({
        responseHeaders: {
          ...details.responseHeaders,
          "Content-Security-Policy": [
            `default-src 'self' 'unsafe-inline' 'unsafe-eval' ${sites};`,
            `script-src 'self' 'unsafe-inline' 'unsafe-eval' ${sites};`,
            `style-src 'self' 'unsafe-inline' 'unsafe-eval' ${sites};`,
            `img-src 'self' data: ${sites};`,
            `font-src 'self' data: ${sites};`,
            `connect-src 'self' ${sites};`,
            "object-src 'none';",
            "base-uri 'self';",
          ],
        },
      });
    });

    weixinReadBrowserView = new BrowserView({
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        sandbox: true,
        session: weixinReadSession,
      },
    });

    weixinReadBrowserView.webContents.on("did-navigate", (event, url) => {
      logService.info("微信读书页面导航到:", url);
      mainWindow.webContents.send("weixin-reader-url-changed", url);

      // 添加对特定 URL 的处理
      const parsedUrl = new URL(url);
      if (
        parsedUrl.hostname === "weread.qq.com" &&
        parsedUrl.pathname.startsWith("/web/reader/")
      ) {
        const match = parsedUrl.pathname.match(/\/web\/reader\/([a-zA-Z0-9]+)/);
        if (match && match[1]) {
          const bookId = match[1];
          handleWeReadUrl(bookId);
        }
      }
    });

    win.setBrowserView(weixinReadBrowserView);
    weixinReadBrowserView.webContents.loadURL("https://weread.qq.com/");

    const debouncedResize = debounce(() => {
      logService.info("debouncedResize");
      if (mainWindow && weixinReadBrowserView) {
        mainWindow.webContents.send("window-resize");
      }
    }, 1000); // 1000ms 的延迟，可以根据需要调整

    win.on("resize", debouncedResize);
  }

  // 设置BrowserView的位置和大小
  updateWeixinReadBrowserViewBounds(contentBounds);
  setupRequestInterceptor(weixinReadBrowserView.webContents.session);
  await setupNetworkListener(weixinReadBrowserView.webContents);
});

function handleNetworkResponse(url: string, responseBody: string) {
  if (!currentBookKey) return; // 如果没有当前书籍，直接返回

  const bookData = globalBookData.get(currentBookKey);
  if (!bookData) return; // 如果没有找到对应的书籍数据，直接返回

  // 这里添加您的规则来匹配不同类型的请求
  if (url.includes("web/book/bookmarklist")) {
    bookData.set("bookmarklist", JSON.parse(responseBody));
  } else if (url.includes("web/book/bestbookmarks")) {
    bookData.set("bestbookmarks", JSON.parse(responseBody));
  }

  // 更新全局数据
  globalBookData.set(currentBookKey, bookData);
}

async function setupNetworkListener(webContents: WebContents) {
  // 启用网络事件
  await webContents.debugger.attach("1.3");
  await webContents.debugger.sendCommand("Network.enable");

  const responseBodyMap = new Map<string, string>();

  webContents.debugger.on("message", (event, method, params) => {
    if (method === "Network.responseReceived") {
      const { requestId, response } = params;
      const { url, mimeType } = response;

      if (
        // url.includes("weread.qq.com") &&
        mimeType.includes("application/json")
      ) {
        webContents.debugger
          .sendCommand("Network.getResponseBody", { requestId })
          .then(({ body, base64Encoded }) => {
            const decodedBody = base64Encoded ? atob(body) : body;
            responseBodyMap.set(requestId, decodedBody);
            if (DEBUG_WEIXIN_READ) {
              logService.info(`API 响应: ${url}`);
              logService.info("响应体:", decodedBody);
            }

            // 调用新的处理函数
            handleNetworkResponse(url, decodedBody);
          })
          .catch((error) => {
            // 打印出错 URL
            logService.error("error URL:", url);
            logService.error("获取响应体时出错:", error);
          });
      }
    }
  });

  webContents.debugger.on("detach", (event, reason) => {
    logService.info("Debugger detached:", reason);
  });
}

const BLOCKED_URLS = [
  "https://weread.qq.com/sentry/",
  // 可以在这里添加其他需要拦截的 URL 前缀
];

function setupRequestInterceptor(sess: Electron.Session) {
  sess.webRequest.onBeforeRequest((details, callback) => {
    const shouldBlock = BLOCKED_URLS.some((url) => details.url.startsWith(url));
    if (shouldBlock) {
      logService.info("拦截到请求:", details.url);
      // logService.info("拦截的请求详情:", details.method, details.uploadData);
      callback({ cancel: true });
    } else {
      callback({ cancel: false });
    }
  });
}

// 新增更新 BrowserView 大小的函数
let lastBounds = { width: 0, height: 0 };

function updateWeixinReadBrowserViewBounds(contentBounds?: {
  x: number;
  y: number;
  width: number;
  height: number;
}) {
  if (!weixinReadBrowserView) return;

  if (
    contentBounds.width !== lastBounds.width ||
    contentBounds.height !== lastBounds.height
  ) {
    weixinReadBrowserView.setBounds({
      x: contentBounds.x,
      y: contentBounds.y,
      width: contentBounds.width,
      height: contentBounds.height,
    });
    lastBounds = { width: contentBounds.width, height: contentBounds.height };
  }
}

ipcMain.on("weixin-read:resize", (event, contentBounds) => {
  const win = BrowserWindow.fromWebContents(event.sender);
  if (win) {
    updateWeixinReadBrowserViewBounds(contentBounds);
  }
});

ipcMain.on("weixin-read:cleanup", (event) => {
  const win = BrowserWindow.fromWebContents(event.sender);
  if (win && weixinReadBrowserView) {
    win.removeBrowserView(weixinReadBrowserView);
    if (DEBUG_WEIXIN_READ) {
      weixinReadBrowserView.webContents.debugger.detach();
    }
    weixinReadBrowserView = null;
  }
});

// // 删除书籍文件
// ipcMain.handle('delete-book-file', async (event, fileId) => {
//   try {
//     const bookFile = await BookFile.findById(fileId);
//     if (!bookFile) {
//       return { success: false, message: '文件不存在' };
//     }

//     // 从 MinIO 删除文件
//     await s3Client.deleteObject({
//       Bucket: 'raybook',
//       Key: bookFile.path
//     }).promise();

//     // 从数据库中删除文件记录
//     await BookFile.findByIdAndDelete(fileId);

//     // 更新相关的 Book 文档
//     await Book.findByIdAndUpdate(bookFile.book, { $pull: { files: fileId } });

//     return { success: true, message: '文件删除成功' };
//   } catch (error) {
//     console.error('删除文件时出错:', error);
//     return { success: false, message: '删除文件失败' };
//   }
// });
