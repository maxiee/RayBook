import { app, BrowserWindow, ipcMain, dialog } from 'electron';
import EPub from 'epub2';
import path from 'path';
import fs from 'fs';
import mongoose, { ObjectId } from 'mongoose';
import Book, { IBook } from './models/Book';
import { IBook as IBookGUI } from './types/Book';
import s3Client from './data/minio/MinioClient';
import { BookFile } from './models/BookFile';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// 连接到 MongoDB, ENV RAYBOOK_MONGO_URI
mongoose.connect(process.env.RAYBOOK_MONGO_URI);

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

function convertDocToObject(doc: any): any {
  const obj = doc.toObject();
  obj._id = obj._id.toString();
  if (obj.files) {
    obj.files = obj.files.map((file: any) => ({
      ...file,
      _id: file._id.toString()
    }));
  }
  // 转换封面图片为 BASE64
  if (obj.coverImage && obj.coverImage.data) {
    obj.coverImage.data = obj.coverImage.data.toString('base64');
  }
  return obj;
}

// 获取书籍详情
ipcMain.handle('get-book-details', async (event, bookId) => {
  try {
    const book = await Book.findById(bookId).populate('files').exec();;
    if (book) {
      return { success: true, book: convertDocToObject(book) };
    } else {
      return { success: false, message: '未找到书籍' };
    }
  } catch (error) {
    console.error('Error fetching book details:', error);
    return { success: false, message: '获取书籍详情失败' };
  }
});

// 更新书籍信息
ipcMain.handle('update-book', async (event, bookData: Partial<IBookGUI>) => {
  try {
    if (!bookData._id) {
      throw new Error('Book ID is required for updating');
    }

    // 查找现有的书籍
    const existingBook = await Book.findById(bookData._id);
    if (!existingBook) {
      return { success: false, message: '未找到要更新的书籍' };
    }

    // 更新书籍
    const updatedBook = await Book.findByIdAndUpdate(
      bookData._id,
      { $set: {
        ...bookData,
        files: bookData.files.map(fileId => new mongoose.Types.ObjectId(fileId._id))
      }},
      { new: true, runValidators: true }
    );

    if (!updatedBook) {
      return { success: false, message: '更新书籍失败' };
    }

    // 转换更新后的书籍数据以发送回渲染进程
    const bookToSend = convertDocToObject(updatedBook);

    return {
      success: true,
      message: '书籍更新成功',
      book: bookToSend
    };
  } catch (error) {
    console.error('更新图书时出错:', error);
    return { success: false, message: '更新图书失败' };
  }
});

// 上传图书文件
ipcMain.handle('upload-book-file', async (event, bookId: string) => {
  try {
    const result = await dialog.showOpenDialog({
      properties: ['openFile'],
      filters: [{ name: 'Book Files', extensions: ['epub', 'pdf', 'mobi'] }],
    });

    if (result.canceled || result.filePaths.length === 0) {
      return { success: false };
    }

    const filePath = result.filePaths[0];
    const fileStats = fs.statSync(filePath);
    const fileName = path.basename(filePath);
    const fileExtension = path.extname(filePath).slice(1);

    // 检查文件是否已存在
    const existingFile = await BookFile.findOne({ filename: fileName });
    if (existingFile) {
      return { success: false, message: '文件已存在' };
    }

    // 上传文件到 MinIO
    const bucketName = 'raybook';
    const objectName = `books/${Date.now()}_${fileName}`;

    console.log('newBookFile bookId: ', bookId);
    // 创建 BookFile 并保存
    const newBookFile = new BookFile({
      filename: fileName,
      format: fileExtension,
      size: fileStats.size,
      path: objectName,
      book: new mongoose.Types.ObjectId(bookId)
    });
    await newBookFile.save();

    // 上传文件到 MinIO
    await s3Client.upload({
      Bucket: bucketName,
      Key: objectName,
      Body: fs.createReadStream(filePath)
    }).promise();

    // 返回文件信息
    return {
      success: true,
      file: {
        _id: newBookFile._id.toString(),
        filename: fileName,
        format: fileExtension,
        size: fileStats.size,
        path: objectName
      }
    };
  } catch (error) {
    console.error('Error uploading file:', error);
    return { success: false };
  }
});

// 处理图书添加
ipcMain.handle('add-book', async (event, bookData: {
  coverBase64: string,
  contentType: string,
  files: Array<{
    filename: string,
    format: string,
    size: number,
  }>;
}) => {
  try {
    // 处理封面图片
    let coverImage;
    if (bookData.coverBase64) {
      const base64Data = bookData.coverBase64.replace(/^data:image\/\w+;base64,/, "");
      const buffer = Buffer.from(base64Data, 'base64');
      coverImage = {
        data: buffer,
        contentType: bookData.contentType
      };
    }

    // 创建新的 Book 文档
    const newBook = new Book({
      ...bookData,
      coverImage,
      // epubPath: epubDestPath
    });


    // 保存书籍文件信息
    const bookFilePromises = bookData.files.map(async (file): Promise<ObjectId> => {
      const newBookFile = new BookFile({
        ...file,
        book: newBook._id
      });
      await newBookFile.save();
      return newBookFile._id as ObjectId;
    });

    newBook.files = await Promise.all(bookFilePromises);

    // 保存到数据库
    await newBook.save();

    return { success: true, message: '图书添加成功' };
  } catch (error) {
    console.error('添加图书时出错:', error);
    return { success: false, message: '添加图书失败' };
  }
});

// 添加新的 IPC 接口用于分页加载最新添加的书籍
ipcMain.handle('get-latest-books', async (event, page = 1, pageSize = 10) => {
  try {
    const skip = (page - 1) * pageSize;
    const books = await Book.find({})
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(pageSize)
      .select('title author coverImage');

    const total = await Book.countDocuments();

    // 转换书籍数据，包括封面图片
    const convertedBooks = books.map(convertDocToObject);

    return {
      success: true,
      data: convertedBooks,
      total,
      currentPage: page,
      pageSize,
    };
  } catch (error) {
    console.error('Error fetching latest books:', error);
    return { success: false, message: '获取最新书籍失败' };
  }
});

// 删除书籍文件
ipcMain.handle('delete-book-file', async (event, fileId) => {
  try {
    const bookFile = await BookFile.findById(fileId);
    if (!bookFile) {
      return { success: false, message: '文件不存在' };
    }

    // 从 MinIO 删除文件
    await s3Client.deleteObject({
      Bucket: 'raybook',
      Key: bookFile.path
    }).promise();

    // 从数据库中删除文件记录
    await BookFile.findByIdAndDelete(fileId);

    // 更新相关的 Book 文档
    await Book.findByIdAndUpdate(bookFile.book, { $pull: { files: fileId } });

    return { success: true, message: '文件删除成功' };
  } catch (error) {
    console.error('删除文件时出错:', error);
    return { success: false, message: '删除文件失败' };
  }
});